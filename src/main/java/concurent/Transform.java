package concurent;

/*Простая про грамма , которая позволяет экспериме нтировать с эффектами
 от изменения порогового значения и уровня параллелизма задачи ForkJoinTask*/

// Для запуска через командную строку
//java FJExperiment 1 1000

import java.util.concurrent.*;

/*Задача ForkJoinTask, которая ( через RecursiveAction )
 трансформирует элементы массива значений douЫe .*/

public class Transform extends RecursiveAction {

    // Порог последовательной обработки , который устанавливается конструктором
    int seqThreshold;

    // Массив , в который будет осуществляться доступ .
    double[] data;

    // Определить , какую часть данных обрабатыва ть .
    int start, end;

    Transform(double[] vals, int s, int e, int t) {
        data = vals;
        start = s;
        end = e;
        seqThreshold = t;
    }

    // Метод , в котором будут происходить параллельные вычисления .
    protected void compute() {
        // Если количество элементов меньше порогового значения ,
        // тогда обрабатывать последова тельно .
        if ((end - start) < seqThreshold) {
            // В следующем коде элементу с четным инде ксом присв аивается
            // квадра тный корень из его исходного значения . Элементу с нечетным
            // индексом присваивае тся кубический корень его исходного значения .
            // Этот код предназначен для простого потребления процессорного
            // времени, чтобы эффекты параллельного выполнения стали более заметными
            for (int i = start; i < end; i++) {
                if ((data[i] % 2) == 0) {
                    data[i] = Math.sqrt(data[i]);
                } else {
                    data[i] = Math.cbrt(data[i]);
                }
            }
        } else {
            // В противном случае продолжить разделение данных на меньшие части .
            // Найти среднюю точку .
            int middle = (start + end) / 2;
            // Запустить новые задачи, используя дополнительно разделенные
            // на части данные.
            invokeAll(new Transform(data, start, middle, seqThreshold),
                            new Transform(data, middle, end, seqThreshold));
        }
    }
}
